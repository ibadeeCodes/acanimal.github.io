{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2015/08/31/how-to-read-from-a-writable-stream-httpserverresponse-in-node","webpackCompilationHash":"642efac6ed852a3b544d","result":{"data":{"markdownRemark":{"html":"<p>I'm working on a personal side project (when I have free time to spend on) where a bunch of middlewares are chained to do something awesome (<em>Take a look at <a href=\"https://github.com/clydeio/clydeio\">ClydeIO</a>. Note it is currently a proof of concept</em>). Remember a middleware is nothing more than a function that receives three parameters: the <code class=\"language-text\">request</code>, the <code class=\"language-text\">response</code> and the <code class=\"language-text\">next</code> function:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">req<span class=\"token punctuation\">,</span> res<span class=\"token punctuation\">,</span> next</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>The <code class=\"language-text\">req</code> parameter is an instance of <code class=\"language-text\">http.IncomingMessage</code>, a readable stream, while the <code class=\"language-text\">res</code> parameter is an instance of <code class=\"language-text\">http.ServerResponse</code>, a writable stream (something similar to Java servlets).</p>\n<p>Usually a middleware reads the request, optionally attach more data or modifies it, maybe writes some content on the response and continues the execution in the next middleware invoking the <code class=\"language-text\">next()</code> function. If any of the middlewares writes content and invokes the <code class=\"language-text\">res.end()</code> method the response is sent to the client and middleware chain is aborted.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token comment\">// First middleware</span>\n<span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">req<span class=\"token punctuation\">,</span> res<span class=\"token punctuation\">,</span> next</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>req<span class=\"token punctuation\">.</span>url <span class=\"token operator\">===</span> <span class=\"token string\">\"/blablabla\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    res<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"I have requested the /blablabla resource\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Continue the middleware chain</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// Second middleware want to read the response content</span>\n<span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">req<span class=\"token punctuation\">,</span> res<span class=\"token punctuation\">,</span> next</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ???</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<blockquote>\n<p>Note, I'm working with <a href=\"https://github.com/senchalabs/connect\">Connect</a> and not <a href=\"http://expressjs.com/\">Express</a>, but the concepts are the same.\nExpress uses the <code class=\"language-text\">send()</code> method to write content, which is based in the <code class=\"language-text\">write()</code> and <code class=\"language-text\">end()</code> core node methods. Also Express extends with request and response object with its own methods.</p>\n</blockquote>\n<p>Now, suppose in a middleware you need to get the current content (the response body) other middlewares has been written. The response is an output stream and it is designed to have write oriented operations: write content, write headers, etc but not read operations. <strong><em><a href=\"http://stackoverflow.com/questions/31851894/nodejs-middleware-how-to-read-from-a-writable-stream-http-serverresponse\">So how we can read the content written on a writable stream?</a></em></strong></p>\n<blockquote>\n<p>Do not confuse the response reference we have in a middleware (or simply in a <code class=\"language-text\">http.Server</code> listener), which is a writable stream, with the object we obtain when using <code class=\"language-text\">http.request()</code>. With <code class=\"language-text\">http.request()</code> we obtain an instance of <code class=\"language-text\">http.ClientRequest</code> and when listen on it for the <code class=\"language-text\">response</code> event we get a <code class=\"language-text\">http.IncomingMessage</code>, a readable stream. That is, the response we obtain is a readable stream where we can read data sent from the server. In a middleware we are the server and are responsible to write data in an output/writable stream.</p>\n</blockquote>\n<p>The solution I found is override the <code class=\"language-text\">write()</code> method.</p>\n<p>The <code class=\"language-text\">write()</code> method is defined by the <code class=\"language-text\">stream.Writable</code> interface and it is mandatory each writable stream class implements it. So, they idea is to override the method in a way we can store the data is written and later invoking the parent method so they what usually do:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token comment\">// Second middleware want to read the response content</span>\n<span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">req<span class=\"token punctuation\">,</span> res<span class=\"token punctuation\">,</span> next</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> data <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">;</span>\n\n  res<span class=\"token punctuation\">.</span>_originalWrite <span class=\"token operator\">=</span> res<span class=\"token punctuation\">.</span>write<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Store reference to the original write method</span>\n  res<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">write</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">chunk<span class=\"token punctuation\">,</span> encoding<span class=\"token punctuation\">,</span> callback</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    data <span class=\"token operator\">+=</span> chunk<span class=\"token punctuation\">;</span>\n\n    res<span class=\"token punctuation\">.</span><span class=\"token function\">_originalWrite</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">,</span> chunk<span class=\"token punctuation\">,</span> encoding<span class=\"token punctuation\">,</span> callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Now, the second middleware can read all the chunks of data any other middleware writes to the response and continues the normal execution of the <code class=\"language-text\">write()</code> function invoking the original version.</p>\n<p>Note, if you need to access the response headers the solution is similar but, in this case, you need to override the methods <code class=\"language-text\">writeHead()</code>, <code class=\"language-text\">setHeader()</code> and <code class=\"language-text\">removeHeader()</code>.</p>","excerpt":"I'm working on a personal side project (when I have free time to spend on) where a bunch of middlewares are chained to do something awesome (Take a look at ClydeIO. Note it is currently a proof of concept). Remember a middleware is nothing more than a function that receives three parameters: the , the  and the  function: The  parameter is an instance of , a readable stream, while the  parameter is an instance of , a writable stream (something similar to Java servlets). Usually a middleware reads the request, optionally attach more data or modifies it, maybe writes some content on the response and continues the execution in the next middleware invoking the  function. If any of the middlewares writes content and invokes the  method the response is sent to the client and middleware chain is aborted. Note, I'm working with Connect and not Express, but the concepts are the same.\nExpress uses the  method to write content, which is based in the  and  core node methods. Also Express extends with request and response object with its own methods. Now, suppose in a middleware you need to get the current content (the response body) other middlewares has been written. The response is an output stream and it is designed to have write oriented operations: write content, write headers, etc but not read operations. So how we can read the content written on a writable stream? Do not confuse the response reference we have in a middleware (or simply in a  listener), which is a writable stream, with the object we obtain when using . With  we obtain an instance of  and when listen on it for the  event we get a , a readable stream. That is, the response we obtain is a readable stream where we can read data sent from the server. In a middleware we are the server and are responsible to write data in an output/writable stream. The solution I found is override the  method. The  method is defined by the  interface and it is mandatory each writable stream class implements it. So, they idea is to override the method in a way we can store the data is written and later invoking the parent method so they what usually do: Now, the second middleware can read all the chunks of data any other middleware writes to the response and continues the normal execution of the  function invoking the original version. Note, if you need to access the response headers the solution is similar but, in this case, you need to override the methods ,  and .","frontmatter":{"date":"31 August, 2015","title":"How to read from a writable stream (http.ServerResponse) in Node"},"fields":{"slug":"/blog/2015/08/31/how-to-read-from-a-writable-stream-httpserverresponse-in-node","readingTime":{"text":"3 min read"}}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/blog/2015/08/31/how-to-read-from-a-writable-stream-httpserverresponse-in-node"}}}