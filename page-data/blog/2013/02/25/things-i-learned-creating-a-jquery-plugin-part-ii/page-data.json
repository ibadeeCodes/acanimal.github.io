{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2013/02/25/things-i-learned-creating-a-jquery-plugin-part-ii","webpackCompilationHash":"1a07f4d853d389c5c378","result":{"data":{"markdownRemark":{"html":"<p>This post is the continuation of the series <a title=\"Things I learnt creating a jQuery Plugin (Part I)\" href=\"//2013/01/15/things-i-learned-creating-a-jquery-plugin-part-i\">Things I learned creating a jQuery Plugin</a>.</p>\n<p>In the first part we have seen how the structure of a jQuery plugin must be, the plugin entry point (so called wrapper function) and how we can control the behavior of a method as a getter or setter.</p>\n<h2>Define default options</h2>\n<p>Your plugin more probably will accept different set of options to allow some configuration. For these reason it is important to define a set of default options which will be applied in cases where no options are specified by the user. Place it within the jQuery wrapper function is a good practice:</p>\n<pre class=\"prettyprint\">//\n// Default options\n//\n$.fn[pluginName].defaults = {\n    opt_A: \"\"\n};</pre>\n<h2>Encapsulate your plugin code</h2>\n<p>A good practice is to encapsulate the logic of our plugin within a function, this way our plugin's entry point function can easily initialize or call the right method.</p>\n<p>For example, in a really simple wrapper function, that simply initializes a plugin's instance on each selected element, we could write something like:</p>\n<pre class=\"prettyprint\">$.fn[pluginName] = function(options) {\n    return this.each(function() {\n        new Plugin(this, options);\n    });\n}</pre>\n<h3>The plugin constructor</h3>\n<p>The main part of your plugin is the constructor function. Usually this function is responsible to initialize the plugin, store a reference to the selected element or merge the passed options with the default ones:</p>\n<pre class=\"prettyprint\">function Plugin(element, options) {\n    // Store references to the selected element\n    this.el = element;\n    this.$el = $(element);\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">// Merge passes options with defaults\nthis.options = $.extend({}, $.fn[pluginName].defaults, options);\n\n// ...other code here...\n\n// Initialize the plugin instance\nthis.init();</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>}</pre></p>\n<h3>Prototype your plugin</h3>\n<p>Once the <code>Plugin</code> function is defined we can modify its prototype adding all the desired methods we want for our plugin.</p>\n<p>There are a couple of methods are a good practice to implement:</p>\n<ul>\n<li>A <code>init</code> method, which initializes each plugins instance: creating new DOM elements, registering listeners, etc</li>\n<li>A <code>destroy</code> method, responsible to free any resource used by the plugin: extra elements, unregister listeners, etc.</li>\n</ul>\n<p>Other methods can be created within your plugin's prototype but remember the convention: <em>Use method names starting with underscore for those methods we want to be private</em>.</p>\n<blockquote><p>If you remember the first part of this series, what really happens is when you call a plugin's method, the wrapper function of our plugin checks if the method's name starts with underscore and if so then avoids the call.</p></blockquote>\n<pre class=\"prettyprint\">//\n// Plugin prototype\n//\nPlugin.prototype = {\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">//\n// Initialize the plugin instance\n//\ninit: function() {\n    ...\n},\n\n//\n// Free resources\n//\ndestroy: function() {\n    ...\n},\n\n//\n// Public method\n//\npublicMethod: function() {\n    ...\n},\n\n//\n// Private method (it starts with an underscore)\n//\n_privateMethod: function() {\n    ...\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>}</pre></p>\n<h3>A note on the <code>destroy</code> method</h3>\n<p>As we have commented, the <code>destroy</code> method must free any resource used by the plugin instance, like extra created elements, unregister listeners, etc</p>\n<p>If you remember the first article, you will notice that the plugin's instance is stored within the selected DOM element where the plugin is applied:</p>\n<pre class=\"prettyprint\">$.fn[pluginName] = function(options) {\n    var args = arguments;\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">if (options === undefined || typeof options === &#39;object&#39;) {\n    // Creates a new plugin instance, for each selected element, and\n    // stores a reference withint the element&#39;s data\n    return this.each(function() {\n        if (!$.data(this, &#39;plugin_&#39; + pluginName)) {\n            $.data(this, &#39;plugin_&#39; + pluginName, new Plugin(this, options));\n        }\n    });\n}\n\n...</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>};</pre></p>\n<p>That occurs in the line:</p>\n<pre class=\"prettyprint\">$.data(this, 'plugin_' + pluginName, new Plugin(this, options));</pre>\n<p>So, the last action in your <code>destroy</code> method must be always remove the plugin's instance reference from the element's data. This can easily done using the reference to the DOM element stored in the plugin instance:</p>\n<pre class=\"prettyprint\">//\n// Free resources\n//\ndestroy: function() {\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">// Remove elements, unregister listerners, etc\n\n// Remove data\nthis.$el.removeData();</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>}</pre></p>\n<h2>Allow the use of callbacks in our plugin</h2>\n<p>It is common jQuery plugins allows to register callback functions to be called when an event or action is generated by the plugins. For example, in the <a href=\"http://www.acuriousanimal.com/tagger.js\">tagger</a> plugin the user can be notified when a new tag is added, removed, clicked, etc.</p>\n<p>Next lines shows the initialization of the tagger plugin setting the parameter <code>fieldSeparator</code> to a value different from the default options value and registering a callback function for the <code>onTagAdded</code> event:</p>\n<pre class=\"prettyprint\">$('#inputID').tagger({\n  fieldSeparator: '|'\n  onTagsAdded: function(tags) {\n    console.log('Added new tag: '+tags+'\\n');\n  }\n});</pre>\n<p>To achieve this we need to make to main steps:</p>\n<ol>\n<li><span style=\"line-height: 13px;\">Define a default and empty callback function in the plugins default options.</span></li>\n<li>At some place of our plugin's code make a call to the callback function.</li>\n</ol>\n<p>Continuing with the sample of the <a href=\"http://www.acuriousanimal.com/tagger.js\">tagger</a> plugin, its default options looks like:</p>\n<pre class=\"prettyprint\">//\n// Default options\n//\n$.fn[pluginName].defaults = {\n    fieldSeparator: \",\",\n    readOnly: false,\n    // Callback invoked when user calls the 'tags' method\n    onTagsAdded: function() {\n    },\n    // Callback invoked when user calls the 'remove' method\n    onTagsRemoved: function() {\n    },\n    // Callback invoked when user calls the 'clear' method.\n    // Note: Internally the 'clear' method uses the 'remove'.\n    onClear: function() {\n    },\n    // Callback invoked when the user click a tag label\n    onClick: function() {\n    }\n};</pre>\n<p>Later, in the method responsible to add new tags to the tag list, a call is made to the <code>onTagsAdded</code> function:</p>\n<pre class=\"prettyprint\">// Adds one or more tags\n// ...\n//\ntags: function(tags) {\n      ...\n      // Call the callback\n      this.options.onTagsAdded.call(this, tags);\n      ...\n    }\n},</pre>\n<blockquote><p>Note how we have forced to set the <code>this</code> object and passed the value of the new added tag to the callback function.</p></blockquote>\n<h2>Summary</h2>\n<p>Ok, this is the end. A short series of two articles to introduce the main concepts to creating jQuery plugins isn't a bad thing when you are looking for help starting with jQuery and custom plugin development.</p>\n<p>Let's try to summarize the main points we have seen in this couple of posts:</p>\n<ul>\n<li>Understand the importance of entry point to your plugin. This is handled in a new function on the <code>$.fn</code> object and is responsible to (or can) control: plugin initialization, call to setter or getter methods, simulate private methods, etc.</li>\n<li>Encapsulate your plugin's functionalities in a prototyped function</li>\n<li>Store, if needed, a reference to the DOM element where your plugin is applied to.</li>\n<li>Remember to implement a <code>destroy</code> method responsible to free all the resources used by your plugin</li>\n<li>Create a default options object that serves as a base to extend it with the options specified by the user</li>\n<li>Keep calm and remember try and error is a (necessary) way to learn</li>\n</ul>\n<h2>References</h2>\n<p>The web is plenty of great information:</p>\n<p><a href=\"http://docs.jquery.com/Plugins/Authoring\">http://docs.jquery.com/Plugins/Authoring </a></p>\n<p><a href=\"http://www.websanova.com/tutorials/jquery/the-ultimate-guide-to-writing-jquery-plugins\">http://www.websanova.com/tutorials/jquery/the-ultimate-guide-to-writing-jquery-plugins</a></p>\n<p><a href=\"http://jqueryboilerplate.com/\">http://jqueryboilerplate.com/ </a></p>\n<p><a href=\"https://github.com/zenorocha/jquery-plugin-patterns\">https://github.com/zenorocha/jquery-plugin-patterns</a></p>\n<p><a href=\"http://coding.smashingmagazine.com/2011/10/11/essential-jquery-plugin-patterns/\">http://coding.smashingmagazine.com/2011/10/11/essential-jquery-plugin-patterns/</a></p>\n<p><a href=\"http://addyosmani.com/resources/essentialjsdesignpatterns/book/#jquerypluginpatterns\">http://addyosmani.com/resources/essentialjsdesignpatterns/book/#jquerypluginpatterns</a></p>\n<p>&nbsp;</p>","excerpt":"This post is the continuation of the series Things I learned creating a jQuery Plugin. } } }; }","frontmatter":{"date":"25 February, 2013","title":"Things I learned creating a jQuery Plugin (Part II)"},"fields":{"slug":"/blog/2013/02/25/things-i-learned-creating-a-jquery-plugin-part-ii","readingTime":{"text":"6 min read"}}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/blog/2013/02/25/things-i-learned-creating-a-jquery-plugin-part-ii"}}}