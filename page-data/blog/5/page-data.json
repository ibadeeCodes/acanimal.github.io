{"componentChunkName":"component---src-templates-blog-list-js","path":"/blog/5","webpackCompilationHash":"4776e6576de27e274acc","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"1da3bea9-4d70-5104-9b51-b1ef2be6bf69","frontmatter":{"title":"The mystery of no flash session variables in Express + Passport auth","date":"30 March, 2015","layout":"post"},"fields":{"slug":"/blog/2015/03/30/the-mystery-of-no-flash-session-variables-in-express-passport-auth/","readingTime":{"text":"5 min read"}},"excerpt":"Recently I started an application using NodeJS with ExpressJS framework and decided to use passport for authenticate the users. As many other times I wanted to use flash messages so, when user authentication fails, the application shows a message informing about bad credentials. Nothing new on the horizon until.... OMG !!! I can't see the flash messages !!! Disclaimer: This is a really stupid history with me as starring. I like to learn from my errors and because of this I decide to write this post both as a punishment and to ensure I don't forget it again. The crime scene I was working implementing a sign up process, where the user writes its credentials and system creates as a new user or returns an error message like \"Sorry, but a username with that email exists\" or similar. Before introduce any code, the flow is as follows: User access the  page via GET method. Data is sent to  resource via POST method, which is responsible to: Check if data is fine, create a new user and redirected to the  page. If a user with the same email exists we redirect again to the  page (that is, using the GET method) with a flash message related to bad credentials. Note: A flash message is a variable stored within a session that is only available once, for the next request. That is if we put a flash variable and renders a page, the flash variable is available but if we render the same (or other) page again the flash variable is not present (it is destroyed). The approximate code for the previous flow is as follows. First, the next code is responsible to receive the post data and register the user: {% highlight javascript %}\n// process the signup form\nrouter.post('/signup', passport.authenticate('local-signup', {\n  successRedirect : '/profile', // redirect to the secure profile section\n  failureRedirect : '/signup', // redirect back to the signup page if there is an error\n  failureFlash : true // allow flash messages\n})); The authentication is delegated to passport, which is implemented as:"}},{"node":{"id":"65d36648-c2ce-52e2-a00f-286813fee597","frontmatter":{"title":"Reading/writing compressed and not compressed files in Java","date":"03 January, 2015","layout":"post"},"fields":{"slug":"/blog/2015/01/03/readingwriting-compressed-and-not-compressed-files-in-java/","readingTime":{"text":"3 min read"}},"excerpt":"Main reason for this post is trying don't repeat yourself (DRY) because, often, I fall in the recursive need to read and write compressed and not compressed files (mainly JSON and CSV). Let's to see first how to read text files. Note I'm working with (relatively small) text files so: The read methods returns an String with the whole content. I'm using  to read line by line. {% highlight java %}\nprivate String readFile(String fileName) {\n    StringBuilder sb = new StringBuilder();\n    try {\n        BufferedReader input = new BufferedReader(new FileReader(new File(fileName)));\n        try {\n            String line = null;\n            while ((line = input.readLine()) != null) {\n                sb.append(line);\n            }\n        } finally {\n            input.close();\n        }\n    } catch (IOException ex) {\n        // Handle exception\n        return null;\n    } }\n{% endhighlight %} Note: there are more than one way to do things. In the entry Best way to read a text file, where you can find many different ways to read a text file depending on your JDK version and the size of the file. Similarly to write a String to a file: {% highlight java %}\nprivate void writeFile(String fileName, String value) {\n    try {\n        FileWriter fw = new FileWriter(fileName);\n        BufferedWriter bw = new BufferedWriter(fw);\n        bw.write(value);\n        bw.close();\n    } catch (IOException ex) {\n        // Handle exception\n    }\n}\n{% endhighlight %} To read/write compressed files, that is with binary data, we need to work with streams and buffers. So to read a GZIP compressed file and obtain a String: {% highlight java %}\nprivate String readCompressedFile(String fileName) {\n    try {\n        GZIPInputStream gis = new GZIPInputStream(new FileInputStream(fileName));\n        ByteArrayOutputStream fos = new ByteArrayOutputStream();\n        byte[] buffer = new byte1024;\n        int len;\n        while ((len = gis.read(buffer)) != -1) {\n            fos.write(buffer, 0, len);\n        }\n        fos.close();\n        gis.close();\n        return new String(fos.toByteArray());\n    } catch (IOException ex) {\n        // Handle exception\n        return null;\n    }\n}\n{% endhighlight %} and similarly to write a String to a GZip compressed file: {% highlight java %}\nprivate void writeCompressedFile(String fileName, String value) {\n    try {\n        InputStream is = new ByteArrayInputStream(value.getBytes());\n        GZIPOutputStream gzipOS = new GZIPOutputStream(new FileOutputStream(fileName));\n        byte[] buffer = new byte1024;\n        int len;\n        while ((len = is.read(buffer)) != -1) {\n            gzipOS.write(buffer, 0, len);\n        }\n        gzipOS.close();\n        is.close();\n    } catch (IOException ex) {\n        // Handle exception\n    }\n}\n{% endhighlight %} References Next you can find a couple of great links with Java code for various JDK versions: Reading and writing text files Reading and writing binary files"}},{"node":{"id":"d235cc0e-11c8-5d32-9a97-690111a52542","frontmatter":{"title":"Why OpenLayers3 does not render my GeoJSON?","date":"30 December, 2014","layout":"post"},"fields":{"slug":"/blog/2014/12/30/why-openlayers3-does-not-render-my-geojson/","readingTime":{"text":"2 min read"}},"excerpt":"OpenLayers3 offers the  class that allows to read data from a GeoJSON source (an URL, a JavaScript object or a text string). Maybe you, like me, has spent some time trying to understand why your GeoJSON data is not rendering properly: projection is fine, your GeoJSON is well formed and validated but OpenLayers3 doesn't return any features and so nothing is rendered in the map. What is the problem? The  class is a subclass of  that uses an  instance to read content: A source class, by definition, acts as a source of features for a vector layers, that is, it is like a container of features. Because of this, the  source is limited to read GeoJSON features and not geometries. So next GeoJSON will be ignored by OpenLayers3 (really if you use de debug version you will see an assertion message): {% highlight javascript %}\n{\n    \"type\": \"Point\",\n    \"coordinates\": \n        -105.01621,\n        39.57422\n    \n}\n{% endhighlight %} While the next is a valid GeoJSON suitable to be read by the source: {% highlight javascript %}\n{\n    \"type\": \"Feature\",\n    \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": \n            -105.01621,\n            39.57422\n        \n    },\n    \"properties\": {\n        \"name\": \"Some feature property\"\n    }\n}\n{% endhighlight %}  That means we can't read GeoJSON geometries? Absolutely no, simply means source classes follows the source concept, and that means, work with features. The  format class allows to read and write features and geometries. To read a GeoJSON file composed of geometries we need to read the geometries and, manually, create a feature for each one. For example: {% highlight javascript %}\nvar point = {\n    \"type\": \"Point\",\n    \"coordinates\": \n        -105.01621,\n        39.57422\n    \n}; // Read the GeoJSON geometries using the format class\nvar format = new ol.format.GeoJSON();\nvar geometry = format.readGeometry(point); // Create a feature using the geometry\nvar feature = new ol.Feature({\n  geometry: geometry,\n  propA: 'Some feature property'\n}); // Add feature to the source of some vector layer\nvectorLayer.getSource().addFeature(feature);\n{% endhighlight %}"}},{"node":{"id":"18333145-ba3a-50dc-acab-d903bd43340a","frontmatter":{"title":"How the JavaScript heatmap implementation works?","date":"23 December, 2014","layout":"post"},"fields":{"slug":"/blog/2014/12/23/how-the-javascript-heatmap-implementation-works/","readingTime":{"text":"2 min read"}},"excerpt":"A heatmap is a powerful way to visualise data. Given a matrix of data each value is represented by a color. The implementation of the heatmap algorithm is expensive in computation terms: for each grid's pixel you need to compute its colour from a set of known values. As you can thing, it is not feasible to be implement it on the client side because map rendering would be really slow.  But OpenLayers3 comes with a handy class, , which allows to render vector data as a heatmap, so the question is: how it is made? Really, the  layer uses a smart approximation to the algorithm which produces great results and is really fast. The steps can be summarised as: A gradient of colors is created as a 1x256 pixel size image. Each known value is rendered in a canvas as a grey blurred point using some radius. This produces a canvas where the blurred points can overlap each other and create more obscure zones. Something similar to this.  Finally, an image is obtained from the canvas and for each pixels a color is assigned. The color is obtained from the previous 1x256 pixel image obtained the color specified by the grey value (which goes from 0..255). The coloured image is then rendered in the map canvas, obtaining a nice effect suited to be used for density maps. The  offers some properties we can use to play better: , , ,  and . This last can be configured per feature, allowing to assign a level of importance to each feature determining in more or less measure the final color."}},{"node":{"id":"62c4e4b3-64b4-5a40-95d6-99b2e06d6211","frontmatter":{"title":"The Book of OpenLayers 3, completed !!!","date":"16 December, 2014","layout":"post"},"fields":{"slug":"/blog/2014/12/16/the-book-of-openlayers-3-completed/","readingTime":{"text":"1 min read"}},"excerpt":"It was a long road but finally it comes true: The Book of OpenLayers 3 is finished.  The chapter Controls and Interactions concludes the exploration of the main concepts related with OpenLayers version 3. This chapter is focused on showing how to work with the two main tools necessary to interact with the maps and its contents. New samples have been created. Remember the source code can be found at https://github.com/acanimal/thebookofopenlayers3 and a running demo is available at http://www.acuriousanimal.com/thebookofopenlayers3/. I must admit finished is not the best word to apply, OpenLayers3 is big, complex and awesome enough to write tons of chapters, but I must put a final dot and leave the typewriter... for a while :) Some of you have contact to me notifying spelling errors. I have given priority to the release of the final chapter. Please don't hesitate to contact me to notify me more error (or anything), my next release will be a maintenance version fixing all that errors. Many of you has suggested me many ideas on features to write about, so I think I will come back with a \"There is more\" really final chapter some day. Thanks for your confidence."}},{"node":{"id":"a83d7310-2157-570a-97bf-9b0ba2dcfb65","frontmatter":{"title":"Things to know when writing a book","date":"15 November, 2014","layout":"post"},"fields":{"slug":"/blog/2014/11/15/things-to-know-when-writing-a-book/","readingTime":{"text":"2 min read"}},"excerpt":"From my short experience, let me summarize some things you must take into account when writing a book. Its is not a mechanical process, it is more related with inspiration, but we must be constant and productive. Everyday is not the best day to write It is a fact, a law of universe. You could desire write but some days your brain is not clear enough, agile enough, fresh enough to write as you like. Don't force yourself. Don't hate yourself to be unable to write as you would like. Relax. Disconnect. Put your head in another tasks. Do some sport. The best thing to do when today isn't the best day to write is not to write. Markdown notation is great Yes, markdown syntax is great. It is simple, clear and powerful. At the beginning, if you come from a complex word processor like Word, Pages, LibreOffice or similar, you feel nude, but later you will appreciate that nudity. Markdown separates your raw writes from the final visualisation. A text editor is enough People tend to drown looking for the perfect tool to make the work. My advice is don't bother you, a simple text editor is enough to write any kind of book (otherwise ask to the hundreds of people that have written using a typewriter). Personally, I prefer a simple text editor over a word processor, because the first isolates the content from the way to visualise it. Of course technology can improve the way we work. We have tons of text editor, classics like vim or emacs text editors, the new ones like SublimeText, TextMate or the Ulysses application, and also, many online text editors, like dillinger.io or StackEdit. Keep cross references organized Some kind of books, like technical books, are plenty of cross references pointing to other sections, chapters or samples. It is vital for the author to maintain these references updated and organized. When using markdown a tend to organize the book as follows: Each chapter in a separate file named  Put a reference on each chapter title like:  Put a reference on each section title as  These simple tips help you organize the whole book references and simplifying the process to create cross references."}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"limit":6,"skip":24,"numPages":18,"currentPage":5}}}