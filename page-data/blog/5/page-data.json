{"componentChunkName":"component---src-templates-blog-list-js","path":"/blog/5","webpackCompilationHash":"94830e9bd36aba932e6a","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"4ce61f35-2426-51a1-8540-02b8592c47f3","frontmatter":{"title":"From SublimeText to Atom text editor","date":"15 July, 2015","layout":"post"},"fields":{"slug":"/blog/2015/07/15/from-sublimetext-to-atom-text-editor/","readingTime":{"text":"2 min read"}},"excerpt":"I have used regularly SublimeText (v2) for the past year. I used it mainly to programming in JavaScript, HTML, CSS and to write in Markdown syntax (I'm sorry but to programming in Java NetBeans continues to be my preferred IDE). In that time I used a bunch of SublimeText plugins to help me in my day to day: Markdown Editing. Provides a decent Markdown color scheme (light and dark) with more robust syntax highlighting and useful Markdown editing features. Markdown Preview. Preview and build your markdown files quickly in your web browser. Markdown TOC. Search headings in document and insert/update TOC(Table Of Contents) to it. DocBlockr. Simplifies writing DocBlock comments in many languages, one of them JavaScript. To the previous list we need to attach the spellchecker, autocomplete, minimap, highlight selected text and some more great core features of SublimeText.  A week ago I start using Atom text editor (v1.0.2) so I looked for a list of similar plugins that helps me in my day to day in the same way as previous plugins on SublimeText: Minimap, A preview of the full source code. Replicates the minimap core feature of SublimeText. Highlight Selected: Double click on a word to highlight it throughout the open file. Replicated the highlight selected text core feature of SublimeText. Markdown TOC: Generate/updates TOC (table of contents) of headlines from parsed markdown file. DocBlockr: Designed to make writing documentation faster and easier. We need to note by default atom.io has support for markdown syntax, autocompletion and spellchecker too."}},{"node":{"id":"1da3bea9-4d70-5104-9b51-b1ef2be6bf69","frontmatter":{"title":"The mystery of no flash session variables in Express + Passport auth","date":"30 March, 2015","layout":"post"},"fields":{"slug":"/blog/2015/03/30/the-mystery-of-no-flash-session-variables-in-express-passport-auth/","readingTime":{"text":"5 min read"}},"excerpt":"Recently I started an application using NodeJS with ExpressJS framework and decided to use passport for authenticate the users. As many other times I wanted to use flash messages so, when user authentication fails, the application shows a message informing about bad credentials. Nothing new on the horizon until.... OMG !!! I can't see the flash messages !!! Disclaimer: This is a really stupid history with me as starring. I like to learn from my errors and because of this I decide to write this post both as a punishment and to ensure I don't forget it again. The crime scene I was working implementing a sign up process, where the user writes its credentials and system creates as a new user or returns an error message like \"Sorry, but a username with that email exists\" or similar. Before introduce any code, the flow is as follows: User access the  page via GET method. Data is sent to  resource via POST method, which is responsible to: Check if data is fine, create a new user and redirected to the  page. If a user with the same email exists we redirect again to the  page (that is, using the GET method) with a flash message related to bad credentials. Note: A flash message is a variable stored within a session that is only available once, for the next request. That is if we put a flash variable and renders a page, the flash variable is available but if we render the same (or other) page again the flash variable is not present (it is destroyed). The approximate code for the previous flow is as follows. First, the next code is responsible to receive the post data and register the user: {% highlight javascript %}\n// process the signup form\nrouter.post('/signup', passport.authenticate('local-signup', {\n  successRedirect : '/profile', // redirect to the secure profile section\n  failureRedirect : '/signup', // redirect back to the signup page if there is an error\n  failureFlash : true // allow flash messages\n})); The authentication is delegated to passport, which is implemented as:"}},{"node":{"id":"65d36648-c2ce-52e2-a00f-286813fee597","frontmatter":{"title":"Reading/writing compressed and not compressed files in Java","date":"03 January, 2015","layout":"post"},"fields":{"slug":"/blog/2015/01/03/readingwriting-compressed-and-not-compressed-files-in-java/","readingTime":{"text":"3 min read"}},"excerpt":"Main reason for this post is trying don't repeat yourself (DRY) because, often, I fall in the recursive need to read and write compressed and not compressed files (mainly JSON and CSV). Let's to see first how to read text files. Note I'm working with (relatively small) text files so: The read methods returns an String with the whole content. I'm using  to read line by line. {% highlight java %}\nprivate String readFile(String fileName) {\n    StringBuilder sb = new StringBuilder();\n    try {\n        BufferedReader input = new BufferedReader(new FileReader(new File(fileName)));\n        try {\n            String line = null;\n            while ((line = input.readLine()) != null) {\n                sb.append(line);\n            }\n        } finally {\n            input.close();\n        }\n    } catch (IOException ex) {\n        // Handle exception\n        return null;\n    } }\n{% endhighlight %} Note: there are more than one way to do things. In the entry Best way to read a text file, where you can find many different ways to read a text file depending on your JDK version and the size of the file. Similarly to write a String to a file: {% highlight java %}\nprivate void writeFile(String fileName, String value) {\n    try {\n        FileWriter fw = new FileWriter(fileName);\n        BufferedWriter bw = new BufferedWriter(fw);\n        bw.write(value);\n        bw.close();\n    } catch (IOException ex) {\n        // Handle exception\n    }\n}\n{% endhighlight %} To read/write compressed files, that is with binary data, we need to work with streams and buffers. So to read a GZIP compressed file and obtain a String: {% highlight java %}\nprivate String readCompressedFile(String fileName) {\n    try {\n        GZIPInputStream gis = new GZIPInputStream(new FileInputStream(fileName));\n        ByteArrayOutputStream fos = new ByteArrayOutputStream();\n        byte[] buffer = new byte1024;\n        int len;\n        while ((len = gis.read(buffer)) != -1) {\n            fos.write(buffer, 0, len);\n        }\n        fos.close();\n        gis.close();\n        return new String(fos.toByteArray());\n    } catch (IOException ex) {\n        // Handle exception\n        return null;\n    }\n}\n{% endhighlight %} and similarly to write a String to a GZip compressed file: {% highlight java %}\nprivate void writeCompressedFile(String fileName, String value) {\n    try {\n        InputStream is = new ByteArrayInputStream(value.getBytes());\n        GZIPOutputStream gzipOS = new GZIPOutputStream(new FileOutputStream(fileName));\n        byte[] buffer = new byte1024;\n        int len;\n        while ((len = is.read(buffer)) != -1) {\n            gzipOS.write(buffer, 0, len);\n        }\n        gzipOS.close();\n        is.close();\n    } catch (IOException ex) {\n        // Handle exception\n    }\n}\n{% endhighlight %} References Next you can find a couple of great links with Java code for various JDK versions: Reading and writing text files Reading and writing binary files"}},{"node":{"id":"d235cc0e-11c8-5d32-9a97-690111a52542","frontmatter":{"title":"Why OpenLayers3 does not render my GeoJSON?","date":"30 December, 2014","layout":"post"},"fields":{"slug":"/blog/2014/12/30/why-openlayers3-does-not-render-my-geojson/","readingTime":{"text":"2 min read"}},"excerpt":"OpenLayers3 offers the  class that allows to read data from a GeoJSON source (an URL, a JavaScript object or a text string). Maybe you, like me, has spent some time trying to understand why your GeoJSON data is not rendering properly: projection is fine, your GeoJSON is well formed and validated but OpenLayers3 doesn't return any features and so nothing is rendered in the map. What is the problem? The  class is a subclass of  that uses an  instance to read content: A source class, by definition, acts as a source of features for a vector layers, that is, it is like a container of features. Because of this, the  source is limited to read GeoJSON features and not geometries. So next GeoJSON will be ignored by OpenLayers3 (really if you use de debug version you will see an assertion message): {% highlight javascript %}\n{\n    \"type\": \"Point\",\n    \"coordinates\": \n        -105.01621,\n        39.57422\n    \n}\n{% endhighlight %} While the next is a valid GeoJSON suitable to be read by the source: {% highlight javascript %}\n{\n    \"type\": \"Feature\",\n    \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": \n            -105.01621,\n            39.57422\n        \n    },\n    \"properties\": {\n        \"name\": \"Some feature property\"\n    }\n}\n{% endhighlight %}  That means we can't read GeoJSON geometries? Absolutely no, simply means source classes follows the source concept, and that means, work with features. The  format class allows to read and write features and geometries. To read a GeoJSON file composed of geometries we need to read the geometries and, manually, create a feature for each one. For example: {% highlight javascript %}\nvar point = {\n    \"type\": \"Point\",\n    \"coordinates\": \n        -105.01621,\n        39.57422\n    \n}; // Read the GeoJSON geometries using the format class\nvar format = new ol.format.GeoJSON();\nvar geometry = format.readGeometry(point); // Create a feature using the geometry\nvar feature = new ol.Feature({\n  geometry: geometry,\n  propA: 'Some feature property'\n}); // Add feature to the source of some vector layer\nvectorLayer.getSource().addFeature(feature);\n{% endhighlight %}"}},{"node":{"id":"18333145-ba3a-50dc-acab-d903bd43340a","frontmatter":{"title":"How the JavaScript heatmap implementation works?","date":"23 December, 2014","layout":"post"},"fields":{"slug":"/blog/2014/12/23/how-the-javascript-heatmap-implementation-works/","readingTime":{"text":"2 min read"}},"excerpt":"A heatmap is a powerful way to visualise data. Given a matrix of data each value is represented by a color. The implementation of the heatmap algorithm is expensive in computation terms: for each grid's pixel you need to compute its colour from a set of known values. As you can thing, it is not feasible to be implement it on the client side because map rendering would be really slow.  But OpenLayers3 comes with a handy class, , which allows to render vector data as a heatmap, so the question is: how it is made? Really, the  layer uses a smart approximation to the algorithm which produces great results and is really fast. The steps can be summarised as: A gradient of colors is created as a 1x256 pixel size image. Each known value is rendered in a canvas as a grey blurred point using some radius. This produces a canvas where the blurred points can overlap each other and create more obscure zones. Something similar to this.  Finally, an image is obtained from the canvas and for each pixels a color is assigned. The color is obtained from the previous 1x256 pixel image obtained the color specified by the grey value (which goes from 0..255). The coloured image is then rendered in the map canvas, obtaining a nice effect suited to be used for density maps. The  offers some properties we can use to play better: , , ,  and . This last can be configured per feature, allowing to assign a level of importance to each feature determining in more or less measure the final color."}},{"node":{"id":"62c4e4b3-64b4-5a40-95d6-99b2e06d6211","frontmatter":{"title":"The Book of OpenLayers 3, completed !!!","date":"16 December, 2014","layout":"post"},"fields":{"slug":"/blog/2014/12/16/the-book-of-openlayers-3-completed/","readingTime":{"text":"1 min read"}},"excerpt":"It was a long road but finally it comes true: The Book of OpenLayers 3 is finished.  The chapter Controls and Interactions concludes the exploration of the main concepts related with OpenLayers version 3. This chapter is focused on showing how to work with the two main tools necessary to interact with the maps and its contents. New samples have been created. Remember the source code can be found at https://github.com/acanimal/thebookofopenlayers3 and a running demo is available at http://www.acuriousanimal.com/thebookofopenlayers3/. I must admit finished is not the best word to apply, OpenLayers3 is big, complex and awesome enough to write tons of chapters, but I must put a final dot and leave the typewriter... for a while :) Some of you have contact to me notifying spelling errors. I have given priority to the release of the final chapter. Please don't hesitate to contact me to notify me more error (or anything), my next release will be a maintenance version fixing all that errors. Many of you has suggested me many ideas on features to write about, so I think I will come back with a \"There is more\" really final chapter some day. Thanks for your confidence."}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"limit":6,"skip":24,"numPages":18,"currentPage":5}}}