{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2011/07/23/generating-map-tiles-without-a-map-server-geotools-the-gis-swissknife/","webpackCompilationHash":"79efcce55e01ed481a07","result":{"data":{"markdownRemark":{"html":"<p>Recently I was playing with latest version of <a href=\"http://geoserver.org/\">GeoServer</a>. It includes the <a href=\"http://geowebcache.org/\">GeoWebCache</a>, something which can improve your server performance greatly. GeoServer solves and helps lots of problems to work and visualize geospatial data but as you know map servers lakes from scalability.</p>\n<p>Because this GeoWebCache is a great tool. Basically, each map request is processed and the result image is stored to be directly returned on subsequent requests. The processed images are stored as a pyramid of tiles depending on the bounding box or zoom level of the request.</p>\n<p>Another way to solve scalability problems is directly pre-generate the pyramid of tiles, something that makes Google, Bing, Yahoo, OpenStreetMaps, etc.</p>\n<h3>What I need?</h3>\n<p>I have a lightnings database with thousands of lightnings for a period of some months. I need to show lightnings in my maps but only those corresponding to a period or interval of time. For example, render the lightnings from 00:00h to 00:30h and allow the user to go forward or backward in time.</p>\n<p>One important thing is I only need an &quot;image&quot; with the information in that period. I don&apos;t need to render each lightning as a feature in the map -this will degrade the performance rendering in a storm with thousands of lightnings per period.</p>\n<h3>The problem</h3>\n<p>So why don&apos;t use GeoServer+GeoWebCache for this? I can configure a layer pointing to my lightning database, make requests and rest assured subsequent call will get the previously created map.</p>\n<p>The problem is at this moment -while I write this post- GeoServer lakes from TIME support in requests. That means if I define a layer from my lightnings table on DB, every GeoServer request will work against all data while I only need a subset of my data -determined by an interval- to be rendered in the requested maps.</p>\n<h3>Adopted solution</h3>\n<p>Ok, be quiet. GeoServer is build on top of <a href=\"http://geotools.org/\">GeoTools</a>, an op<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 476px;\">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 26.260504201680675%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAABC0lEQVQY02NgYAhgYfCT9WWp5MsWKmePkSuTNmGgCFQL+jLESvcz+shkMVT7mctXM/hJN7NpMNhr6TJ4qsYzeKiyMXjrczHoM7AypNYIMzReTmKoPxPM0HCOB6y/4SwbEJsBsTYQszKwNfPkM0ziM2eQZJBmqJ8ylWHiymusOUqpDK4qSxk81Y4CDdwBxFsZPNW3M7jKzgMaNhto2C6G+rM7gAasAGIQfRCIzwDxZAauDIkUmXrBRJ0NDNLs3WLJjNnudxn8VX0Y3FQcgQZ1AnEpEBczeGqWMTjwxTM0XbUEGhoENLAZaEA2ELcBcS4Qg/hVDAwmuvw8UXLVfEkyS1jjpVYx+PJlUhKCANtcUhOqzVXJAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"geotools logo\" title=\"geotools logo\" src=\"/static/c80ab8ff88c588985357e3b39d58d8ad/c6717/geotools-logo.png\" srcset=\"/static/c80ab8ff88c588985357e3b39d58d8ad/19bd1/geotools-logo.png 163w,\n/static/c80ab8ff88c588985357e3b39d58d8ad/d3bcb/geotools-logo.png 325w,\n/static/c80ab8ff88c588985357e3b39d58d8ad/c6717/geotools-logo.png 476w\" sizes=\"(max-width: 476px) 100vw, 476px\" loading=\"lazy\">\n    </span>en source Java library which provides standards compliant methods for the manipulation of geospatial data and, more important, GeoTools library implements <a href=\"http://www.opengeospatial.org\">Open Geospatial Consortium</a> (OGC) specifications as they are developed.</p>\n<p>With all this the solution seems easy: code a program to query the desired period of lightning data and generate a pyramid of tiles (for the desired levels).</p>\n<h2>&#xA0;A brief description of the implementation</h2>\n<p>Next is a brief summary of things to do, or take into account, to generate your own pyramid of tiles programmatically with Geotools.</p>\n<p>All the lightnings information is stored on a PostgreSQL/PostGIS table called &apos;lightnings&apos;. Data related with a lightning are: date (the UTC instant in which the lightning occurs, represented as a long number in <a href=\"http://en.wikipedia.org/wiki/Unix_time\">Unix time</a>), position (latitude/longitude/altitude), value and sign (the electric charge).</p>\n<h3>Set the DataSource connection</h3>\n<p>GeoTools tries to simplify thing and because this it tries to abstracts as much as possible. Features can be provided from many source: files (shapefiles, GML, ...) or a database (PostgreSQL/PostGIS, Oracle, ...).</p>\n<p>The first step then is to set a DataSource instance pointing to our database:</p>\n<pre class=\"brush:java\">Map&lt;String, Object&gt; params = new HashMap&lt;String, Object&gt;();\nparams.put(PostgisNGDataStoreFactory.DBTYPE.key, dbconn.getType());\nparams.put(PostgisNGDataStoreFactory.HOST.key, dbconn.getHost());\nparams.put(PostgisNGDataStoreFactory.PORT.key, dbconn.getPort());\nparams.put(PostgisNGDataStoreFactory.SCHEMA.key, &quot;public&quot;);\nparams.put(PostgisNGDataStoreFactory.DATABASE.key, dbconn.getDatabase());\nparams.put(PostgisNGDataStoreFactory.USER.key, dbconn.getUser());\nparams.put(PostgisNGDataStoreFactory.PASSWD.key, dbconn.getPassword());\nparams.put(PostgisNGDataStoreFactory.EXPOSE_PK.key, true);</pre>\n<p>// Get lightning store\nDataStore dataStore = DataStoreFinder.getDataStore(params);\nSimpleFeatureSource sfs = dataStore.getFeatureSource(\"lightnings\");</pre></p>\n<blockquote><p>Note: 'dbconn' is an object which stores my DB connection parameters.</p></blockquote>\n<h3>Filtering data</h3>\n<p>We don't want to get all the lightnings in the database but only those withing a period of tim, so what we need is to filter the data using Filter classes. Given a period of time represented by values 'long start_date' and 'long end_date' we can define the desired filter as:</p>\n<pre class=\"brush:java\">FilterFactory2 filterFactory = CommonFactoryFinder.getFilterFactory2(null);\n// Create filter for specified initial and end dates\nFilter filterStart = filterFactory.greaterOrEqual(filterFactory.property(\"date\"), filterFactory.literal(start_date));\nFilter filterEnd = filterFactory.less(filterFactory.property(\"date\"), filterFactory.literal(end_date));\nFilter filterTime = filterFactory.and(filterStart, filterEnd);</pre>\n<h3>Create styles before rendering for features</h3>\n<p>There are some ways to create styles for our features. One is to use a SLD document and the other is doing programmatically.</p>\n<p>In my case, I chose to use the second form so here is a bit of cumbersome code (I ommited the try/catch section) which create the desired style to identify positive and negative lightnings.</p>\n<pre class=\"brush:java\">// Create style\nStyleBuilder styleBuilder = new StyleBuilder();\nStyleFactory styleFactory = styleBuilder.getStyleFactory();\nFilterFactory2 filterFactory = styleBuilder.getFilterFactory();\n<p>// Style for Positivos\nGraphic grP = styleFactory.createDefaultGraphic();\nMark markP = styleFactory.getCircleMark();\nmarkP.setStroke(styleFactory.createStroke(filterFactory.literal(Color.BLUE), filterFactory.literal(1)));\nmarkP.setFill(styleFactory.createFill(filterFactory.literal(Color.CYAN)));\ngrP.graphicalSymbols().clear();\ngrP.graphicalSymbols().add(markP);\ngrP.setSize(filterFactory.literal(5));</p>\n<p>// Style for Negativos\nGraphic grN = styleFactory.createDefaultGraphic();\nMark markN = styleFactory.getCircleMark();\nmarkN.setStroke(styleFactory.createStroke(filterFactory.literal(Color.RED), filterFactory.literal(1)));\nmarkN.setFill(styleFactory.createFill(filterFactory.literal(Color.ORANGE)));\ngrN.graphicalSymbols().clear();\ngrN.graphicalSymbols().add(markN);\ngrN.setSize(filterFactory.literal(5));</p>\n<p>Filter filterPositiveValor = ff.and(filter, CQL.toFilter(\"value >= 0\"));\nFilter filterNegativeValor = ff.and(filter, CQL.toFilter(\"value &#x3C; 0\"));</p>\n<p>// Create symbols and rules to render every feature\nPointSymbolizer symPositivos = styleFactory.createPointSymbolizer(grP, null);\nPointSymbolizer symNegativos = styleFactory.createPointSymbolizer(grN, null);</p>\n<p>Rule ruleP = styleFactory.createRule();\nruleP.symbolizers().add(symPositivos);\nruleP.setFilter(filterPositiveValor);\nFeatureTypeStyle ftsP = styleFactory.createFeatureTypeStyle(new Rule[]{ruleP});</p>\n<p>Rule ruleN = styleFactory.createRule();\nruleN.symbolizers().add(symNegativos);\nruleN.setFilter(filterNegativeValor);\nFeatureTypeStyle ftsN = styleFactory.createFeatureTypeStyle(new Rule[]{ruleN});</p>\n<p>// Finally create out style\nStyle style = styleFactory.createStyle();\nstyle.featureTypeStyles().add(ftsP);\nstyle.featureTypeStyles().add(ftsN);</pre></p>\n<h3>Create the map and render to a file</h3>\n<p>The map creating is straightforward:</p>\n<pre class=\"brush:java\">MapContext map = new DefaultMapContext();\nCoordinateReferenceSystem crs = CRS.decode(\"EPSG:3785\");\nmap.setCoordinateReferenceSystem(crs);</pre>\n<p>and then render it to a file. I will paste here the code on theÂ <a href=\"http://docs.geotools.org/latest/userguide/library/render/gtrenderer.html\">GTRenderer tutorial</a>. You can play a bit with the code and change some values: area of interest, size of the output image, etc.</p>\n<pre class=\"brush:java\">public void saveImage(final MapContent map, final String file, final int imageWidth) {\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">GTRenderer renderer = new StreamingRenderer();\nrenderer.setMapContent(map);\n\nRectangle imageBounds = null;\nReferencedEnvelope mapBounds = null;\ntry {\n    mapBounds = map.getMaxBounds();\n    double heightToWidth = mapBounds.getSpan(1) / mapBounds.getSpan(0);\n    imageBounds = new Rectangle(\n            0, 0, imageWidth, (int) Math.round(imageWidth * heightToWidth));\n\n} catch (Exception e) {\n    // failed to access map layers\n    throw new RuntimeException(e);\n}\n\nBufferedImage image = new BufferedImage(imageBounds.width, imageBounds.height, BufferedImage.TYPE_INT_RGB);\n\nGraphics2D gr = image.createGraphics();\ngr.setPaint(Color.WHITE);\ngr.fill(imageBounds);\n\ntry {\n    renderer.paint(gr, imageBounds, mapBounds);\n    File fileToSave = new File(file);\n    ImageIO.write(image, &quot;jpeg&quot;, fileToSave);\n\n} catch (IOException e) {\n    throw new RuntimeException(e);\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>}</pre></p>\n<h1>Conclusions</h1>\n<p>Every tool is designed and built with a goal in mind, because this normally the use of a map server is always the proper selection. But sometimes you have specific needs that general tools doesn't solve and here is when open source project like GeoTools can help you.</p>\n<p>I would to note that programing this way the image generation is much more faster than use of GeoServer because we are avoiding lots of intermediate steps a map server does: get request, parse, check and validate parameters and once query is executed, image composed it must be returned to the client via HTTP protocol.</p>\n<h1>References</h1>\n<p><a href=\"http://docs.geotools.org\">http://docs.geotools.org</a></p>\n<p><a href=\"http://docs.geotools.org/latest/userguide/library/render/gtrenderer.html\">http://docs.geotools.org/latest/userguide/library/render/gtrenderer.html</a></p>\n<p><a href=\"http://docs.geotools.org/stable/tutorials/filter/query.html\">http://docs.geotools.org/stable/tutorials/filter/query.html</a></p>\n<p>&nbsp;</p>","excerpt":"Recently I was playing with latest version of GeoServer. It includes the GeoWebCache, something which can improve your server performance greatly. GeoServer solves and helps lots of problems to work and visualize geospatial data but as you know map servers lakes from scalability. // Get lightning store\nDataStore dataStore = DataStoreFinder.getDataStore(params);\nSimpleFeatureSource sfs = dataStore.getFeatureSource(\"lightnings\"); // Style for Positivos\nGraphic grP = styleFactory.createDefaultGraphic();\nMark markP = styleFactory.getCircleMark();\nmarkP.setStroke(styleFactory.createStroke(filterFactory.literal(Color.BLUE), filterFactory.literal(1)));\nmarkP.setFill(styleFactory.createFill(filterFactory.literal(Color.CYAN)));\ngrP.graphicalSymbols().clear();\ngrP.graphicalSymbols().add(markP);\ngrP.setSize(filterFactory.literal(5)); // Style for Negativos\nGraphic grN = styleFactory.createDefaultGraphic();\nMark markN = styleFactory.getCircleMark();\nmarkN.setStroke(styleFactory.createStroke(filterFactory.literal(Color.RED), filterFactory.literal(1)));\nmarkN.setFill(styleFactory.createFill(filterFactory.literal(Color.ORANGE)));\ngrN.graphicalSymbols().clear();\ngrN.graphicalSymbols().add(markN);\ngrN.setSize(filterFactory.literal(5)); Filter filterPositiveValor = ff.and(filter, CQL.toFilter(\"value >= 0\"));\nFilter filterNegativeValor = ff.and(filter, CQL.toFilter(\"value < 0\")); // Create symbols and rules to render every feature\nPointSymbolizer symPositivos = styleFactory.createPointSymbolizer(grP, null);\nPointSymbolizer symNegativos = styleFactory.createPointSymbolizer(grN, null); Rule ruleP = styleFactory.createRule();\nruleP.symbolizers().add(symPositivos);\nruleP.setFilter(filterPositiveValor);\nFeatureTypeStyle ftsP = styleFactory.createFeatureTypeStyle(new Rule[]{ruleP}); Rule ruleN = styleFactory.createRule();\nruleN.symbolizers().add(symNegativos);\nruleN.setFilter(filterNegativeValor);\nFeatureTypeStyle ftsN = styleFactory.createFeatureTypeStyle(new Rule[]{ruleN}); // Finally create out style\nStyle style = styleFactory.createStyle();\nstyle.featureTypeStyles().add(ftsP);\nstyle.featureTypeStyles().add(ftsN); }","frontmatter":{"date":"23 July, 2011","title":"Generating map tiles without a map server. GeoTools the GIS swissknife."},"fields":{"slug":"/blog/2011/07/23/generating-map-tiles-without-a-map-server-geotools-the-gis-swissknife/","readingTime":{"text":"6 min read"}}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/blog/2011/07/23/generating-map-tiles-without-a-map-server-geotools-the-gis-swissknife/"}}}